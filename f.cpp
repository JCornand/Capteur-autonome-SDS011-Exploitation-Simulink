//
	//déclaration de mes vairables
	int fd_air, n;
	unsigned char commande [9];
	unsigned char retour[9];
	long int res;

	int fd_air1, ne;
	char commandes [9];
	char retoure[9];
	long int rese;


	//
	//test du passage de paramètres
	if(argc != 3){
		printf("2 paramètres attendus veillez refaire, 2 ème argument /dev/ttyUSB0 ou 1\n");
		exit(-1);
	}

	printf("Le nombre d'argments passer est:%d\n\n",argc);
	printf("Nom de l'éxé: %s\nCommunication sur: %s\n",argv[0],argv[1]);


	//
	//param_liaison_serie=(9600,N,8,1);
	fd_air = open(argv[1],O_RDWR | O_NOCTTY | O_NDELAY); //| O_NDELAY);// /dev/ttyS0 port 1 de linus,ndelay ne mets pas ne pause le programme si problème avec DCD
	//rdwr pour lire et écrire,RDONLY pour lire uniquement
	fcntl(fd_air, F_SETFL, 0);
	struct termios options;


	if (fd_air == -1){
	  
	  	printf("\nerreur ouverture port série\n");
	  	exit(-1);
	  }
	else{
		printf("\nport série ouvert\n");
	}

	
	tcgetattr(fd_air, &options);//cherche les paramètres de la liason et les mets dans la struct
	options.c_cflag &= ~PARENB;
	options.c_cflag &= ~CSTOPB;
	options.c_cflag &= ~CSIZE;
	options.c_cflag |= CS8;
	cfsetispeed(&options, B9600);cfsetospeed(&options, B9600);//définis la vitesse ici 4800bauds
	options.c_cflag |= (CLOCAL | CREAD);
	tcsetattr(fd_air, TCSANOW, &options);//rentre les paramètres dedans


	//
	//préparation de la commande read gas concentration
	
	commande[0]=0xAA;//entête du message contient AA
	commande[1]=0xC0;//commande contient C0
	commande[2]=0x00;//PM2.5 octet faible
	commande[3]=0x00;//PM2.5 octet élévé
	commande[4]=0x00;//PM10 petit octet
	commande[5]=0x00;//PM10 haut-octet
	commande[6]=0xFF;//0(réservé)
	commande[7]=0xFF;//0(réservé)
	//commande[8]=0x00;//Somme de contrôle
	commande[9]=0xAB;//Remorque du message AB
	
    //
	//émettre la commande read gas concentration
	while(10){
		n = write(fd_air, commande, 9);
		if (n < 0){
		perror("Write\n");
		close(fd_air);//ferme le socket
		exit(0);
		}

		printf("écriture réussit\n\n");

		//
		//lire
	
		read(fd_air,&retour,9);

		//
		//calcul+affichage
		res =  ((retour[4] * 256) + retour[3]) / 10;
		printf("PM2.5:%ldug/m3\n\n",res);
		res = ((retour[6] * 256) + retour[5]) / 10 ;
		printf("PM10:%ldug/m3\n\n",res);
		//
		//afficher 
		
		sleep(1);
	}
	//
	//déclaration de mes vairables
	

	//
	//param_liaison_serie=(9600,N,8,1);
	fd_air1 = open(argv[1],O_RDWR | O_NOCTTY | O_NDELAY); //| O_NDELAY);// /dev/ttyS0 port 1 de linus,ndelay ne mets pas ne pause le programme si problème avec DCD
	//rdwr pour lire et écrire,RDONLY pour lire uniquement
	fcntl(fd_air1, F_SETFL, FNDELAY);

	if (fd_ai1r == -1){
	  
	  	printf("\nerreur ouverture port série\n");
	  	exit(1);
	  }
	else{
		printf("\nport série ouvert\n");
	}

	
	tcgetattr(fd_air1, &options);//cherche les paramètres de la liason et les mets dans la struct
	options.c_cflag &= ~PARENB;
	options.c_cflag &= ~CSTOPB;
	options.c_cflag &= ~CSIZE;
	options.c_cflag |= CS8;
	cfsetispeed(&options, B9600);cfsetospeed(&options, B9600);//définis la vitesse ici 4800bauds
	options.c_cflag |= (CLOCAL | CREAD);
	tcsetattr(fd_air1, TCSANOW, &options);//rentre les paramètres dedans


	//
	//préparation de la commande read gas concentration
	
	commandes[0]=0XFF;
	commandes[1]=0x01;
	commandes[2]=0x86;
	commandes[3]=0x00;
	commandes[4]=0x00;
	commandes[5]=0x00;
	commandes[6]=0x00;
	commandes[7]=0x00;
	commandes[8]=0x79;
	
    //
	//émettre la commande read gas concentration
	while(10){
		n = write(fd_air1, commandes, 9);
		if (n < 0){
		perror("Write\n");
		close(fd_air1);//ferme le socket
		exit(0);
		}

		printf("écriture réussit\n");

		//
		//lire
	
		read(fd_air1,&retour,9);

		//
		//calcul
		res = retour[2]*256+retour[3];
	
		//
		//afficher 
		printf("La concentration de co2 est de:%ldppm\n",res);
		sleep(1);
	}
	
	
	close(fd_air1);//ferme le socket

	
	close(fd_air0);//ferme le socket

	exit(0);
}